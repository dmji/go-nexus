// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateLdapServerXo create ldap server xo
//
// swagger:model CreateLdapServerXo
type CreateLdapServerXo struct {

	// The password to bind with. Required if authScheme other than none.
	// Required: true
	AuthPassword *string `json:"authPassword"`

	// The SASL realm to bind to. Required if authScheme is CRAM_MD5 or DIGEST_MD5
	// Example: example.com
	AuthRealm string `json:"authRealm,omitempty"`

	// Authentication scheme used for connecting to LDAP server
	// Required: true
	// Enum: ["NONE","SIMPLE","DIGEST_MD5","CRAM_MD5"]
	AuthScheme *string `json:"authScheme"`

	// This must be a fully qualified username if simple authentication is used. Required if authScheme other than none.
	AuthUsername string `json:"authUsername,omitempty"`

	// How long to wait before retrying
	// Required: true
	ConnectionRetryDelaySeconds *int32 `json:"connectionRetryDelaySeconds"`

	// How long to wait before timeout
	// Example: 1
	// Required: true
	// Maximum: 3600
	// Minimum: 1
	ConnectionTimeoutSeconds *int32 `json:"connectionTimeoutSeconds"`

	// The relative DN where group objects are found (e.g. ou=Group). This value will have the Search base DN value appended to form the full Group search base DN.
	// Example: ou=Group
	GroupBaseDn string `json:"groupBaseDn,omitempty"`

	// This field specifies the attribute of the Object class that defines the Group ID. Required if groupType is static
	// Example: cn
	GroupIDAttribute string `json:"groupIdAttribute,omitempty"`

	// LDAP attribute containing the usernames for the group. Required if groupType is static
	// Example: memberUid
	GroupMemberAttribute string `json:"groupMemberAttribute,omitempty"`

	// The format of user ID stored in the group member attribute. Required if groupType is static
	// Example: uid=${username},ou=people,dc=example,dc=com
	GroupMemberFormat string `json:"groupMemberFormat,omitempty"`

	// LDAP class for group objects. Required if groupType is static
	// Example: posixGroup
	GroupObjectClass string `json:"groupObjectClass,omitempty"`

	// Are groups located in structures below the group base DN
	GroupSubtree bool `json:"groupSubtree,omitempty"`

	// Defines a type of groups used: static (a group contains a list of users) or dynamic (a user contains a list of groups). Required if ldapGroupsAsRoles is true.
	// Required: true
	// Enum: ["static","dynamic"]
	GroupType *string `json:"groupType"`

	// LDAP server connection hostname
	// Required: true
	Host *string `json:"host"`

	// Denotes whether LDAP assigned roles are used as Nexus Repository Manager roles
	LdapGroupsAsRoles bool `json:"ldapGroupsAsRoles,omitempty"`

	// How many retry attempts
	// Required: true
	MaxIncidentsCount *int32 `json:"maxIncidentsCount"`

	// LDAP server name
	// Required: true
	Name *string `json:"name"`

	// LDAP server connection port to use
	// Example: 636
	// Required: true
	Port *int32 `json:"port"`

	// LDAP server connection Protocol to use
	// Required: true
	// Enum: ["ldap","ldaps"]
	Protocol *string `json:"protocol"`

	// LDAP location to be added to the connection URL
	// Example: dc=example,dc=com
	// Required: true
	SearchBase *string `json:"searchBase"`

	// Whether to use certificates stored in Nexus Repository Manager's truststore
	UseTrustStore bool `json:"useTrustStore,omitempty"`

	// The relative DN where user objects are found (e.g. ou=people). This value will have the Search base DN value appended to form the full User search base DN.
	// Example: ou=people
	UserBaseDn string `json:"userBaseDn,omitempty"`

	// This is used to find an email address given the user ID
	// Example: mail
	UserEmailAddressAttribute string `json:"userEmailAddressAttribute,omitempty"`

	// This is used to find a user given its user ID
	// Example: uid
	UserIDAttribute string `json:"userIdAttribute,omitempty"`

	// LDAP search filter to limit user search
	// Example: (|(mail=*@example.com)(uid=dom*))
	UserLdapFilter string `json:"userLdapFilter,omitempty"`

	// Set this to the attribute used to store the attribute which holds groups DN in the user object. Required if groupType is dynamic
	// Example: memberOf
	UserMemberOfAttribute string `json:"userMemberOfAttribute,omitempty"`

	// LDAP class for user objects
	// Example: inetOrgPerson
	UserObjectClass string `json:"userObjectClass,omitempty"`

	// If this field is blank the user will be authenticated against a bind with the LDAP server
	UserPasswordAttribute string `json:"userPasswordAttribute,omitempty"`

	// This is used to find a real name given the user ID
	// Example: cn
	UserRealNameAttribute string `json:"userRealNameAttribute,omitempty"`

	// Are users located in structures below the user base DN?
	UserSubtree bool `json:"userSubtree,omitempty"`
}

// Validate validates this create ldap server xo
func (m *CreateLdapServerXo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthPassword(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthScheme(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectionRetryDelaySeconds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectionTimeoutSeconds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHost(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxIncidentsCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePort(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSearchBase(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateLdapServerXo) validateAuthPassword(formats strfmt.Registry) error {

	if err := validate.Required("authPassword", "body", m.AuthPassword); err != nil {
		return err
	}

	return nil
}

var createLdapServerXoTypeAuthSchemePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NONE","SIMPLE","DIGEST_MD5","CRAM_MD5"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createLdapServerXoTypeAuthSchemePropEnum = append(createLdapServerXoTypeAuthSchemePropEnum, v)
	}
}

const (

	// CreateLdapServerXoAuthSchemeNONE captures enum value "NONE"
	CreateLdapServerXoAuthSchemeNONE string = "NONE"

	// CreateLdapServerXoAuthSchemeSIMPLE captures enum value "SIMPLE"
	CreateLdapServerXoAuthSchemeSIMPLE string = "SIMPLE"

	// CreateLdapServerXoAuthSchemeDIGESTMD5 captures enum value "DIGEST_MD5"
	CreateLdapServerXoAuthSchemeDIGESTMD5 string = "DIGEST_MD5"

	// CreateLdapServerXoAuthSchemeCRAMMD5 captures enum value "CRAM_MD5"
	CreateLdapServerXoAuthSchemeCRAMMD5 string = "CRAM_MD5"
)

// prop value enum
func (m *CreateLdapServerXo) validateAuthSchemeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createLdapServerXoTypeAuthSchemePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateLdapServerXo) validateAuthScheme(formats strfmt.Registry) error {

	if err := validate.Required("authScheme", "body", m.AuthScheme); err != nil {
		return err
	}

	// value enum
	if err := m.validateAuthSchemeEnum("authScheme", "body", *m.AuthScheme); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapServerXo) validateConnectionRetryDelaySeconds(formats strfmt.Registry) error {

	if err := validate.Required("connectionRetryDelaySeconds", "body", m.ConnectionRetryDelaySeconds); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapServerXo) validateConnectionTimeoutSeconds(formats strfmt.Registry) error {

	if err := validate.Required("connectionTimeoutSeconds", "body", m.ConnectionTimeoutSeconds); err != nil {
		return err
	}

	if err := validate.MinimumInt("connectionTimeoutSeconds", "body", int64(*m.ConnectionTimeoutSeconds), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("connectionTimeoutSeconds", "body", int64(*m.ConnectionTimeoutSeconds), 3600, false); err != nil {
		return err
	}

	return nil
}

var createLdapServerXoTypeGroupTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["static","dynamic"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createLdapServerXoTypeGroupTypePropEnum = append(createLdapServerXoTypeGroupTypePropEnum, v)
	}
}

const (

	// CreateLdapServerXoGroupTypeStatic captures enum value "static"
	CreateLdapServerXoGroupTypeStatic string = "static"

	// CreateLdapServerXoGroupTypeDynamic captures enum value "dynamic"
	CreateLdapServerXoGroupTypeDynamic string = "dynamic"
)

// prop value enum
func (m *CreateLdapServerXo) validateGroupTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createLdapServerXoTypeGroupTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateLdapServerXo) validateGroupType(formats strfmt.Registry) error {

	if err := validate.Required("groupType", "body", m.GroupType); err != nil {
		return err
	}

	// value enum
	if err := m.validateGroupTypeEnum("groupType", "body", *m.GroupType); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapServerXo) validateHost(formats strfmt.Registry) error {

	if err := validate.Required("host", "body", m.Host); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapServerXo) validateMaxIncidentsCount(formats strfmt.Registry) error {

	if err := validate.Required("maxIncidentsCount", "body", m.MaxIncidentsCount); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapServerXo) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapServerXo) validatePort(formats strfmt.Registry) error {

	if err := validate.Required("port", "body", m.Port); err != nil {
		return err
	}

	return nil
}

var createLdapServerXoTypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ldap","ldaps"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createLdapServerXoTypeProtocolPropEnum = append(createLdapServerXoTypeProtocolPropEnum, v)
	}
}

const (

	// CreateLdapServerXoProtocolLdap captures enum value "ldap"
	CreateLdapServerXoProtocolLdap string = "ldap"

	// CreateLdapServerXoProtocolLdaps captures enum value "ldaps"
	CreateLdapServerXoProtocolLdaps string = "ldaps"
)

// prop value enum
func (m *CreateLdapServerXo) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createLdapServerXoTypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateLdapServerXo) validateProtocol(formats strfmt.Registry) error {

	if err := validate.Required("protocol", "body", m.Protocol); err != nil {
		return err
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", *m.Protocol); err != nil {
		return err
	}

	return nil
}

func (m *CreateLdapServerXo) validateSearchBase(formats strfmt.Registry) error {

	if err := validate.Required("searchBase", "body", m.SearchBase); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create ldap server xo based on context it is used
func (m *CreateLdapServerXo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CreateLdapServerXo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateLdapServerXo) UnmarshalBinary(b []byte) error {
	var res CreateLdapServerXo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
