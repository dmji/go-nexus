package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"regexp"
	"strings"

	orderedmap "github.com/wk8/go-ordered-map/v2"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

func main() {
	inputFile := flag.String("input", "../../swagger.json", "Input JSON file")
	outputFile := flag.String("output", "swagger.json", "Output JSON file")
	flag.Parse()

	inputData, err := os.ReadFile(*inputFile)
	if err != nil {
		exitWithError(fmt.Sprintf("Error reading input file: %v", err))
	}

	var data interface{}
	if err := json.Unmarshal(inputData, &data); err != nil {
		exitWithError(fmt.Sprintf("Error decoding JSON: %v", err))
	}

	processed := processOrdered(convertToOrdered(data), "", "")

	output, err := os.Create(*outputFile)
	if err != nil {
		exitWithError(fmt.Sprintf("Error creating output file: %v", err))
	}
	defer output.Close()

	encoder := json.NewEncoder(output)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(processed); err != nil {
		exitWithError(fmt.Sprintf("Error encoding JSON: %v", err))
	}

	// remake
	inputDataSwagger, err := os.ReadFile(*outputFile)
	if err != nil {
		exitWithError(fmt.Sprintf("Error reading input file: %v", err))
	}

	var dataSwagger AutoGenerated
	if err := json.Unmarshal(inputDataSwagger, &dataSwagger); err != nil {
		exitWithError(fmt.Sprintf("Error decoding JSON: %v", err))
	}

	outputSwagger, err := os.Create("swagger.json")
	if err != nil {
		exitWithError(fmt.Sprintf("Error creating output file: %v", err))
	}
	defer outputSwagger.Close()

	encoderSwagger := json.NewEncoder(outputSwagger)
	encoderSwagger.SetIndent("", "  ")
	if err := encoderSwagger.Encode(dataSwagger); err != nil {
		exitWithError(fmt.Sprintf("Error encoding JSON: %v", err))
	}
}

func processOrdered(data interface{}, grandParent, parent string) interface{} {
	switch v := data.(type) {
	case *orderedmap.OrderedMap[string, interface{}]:
		_, hasSummary := getStringFromOrderedMap(v, "summary")
		_, hasOperationId := v.Get("operationId")

		if hasSummary && hasOperationId {
			body := formatPath(grandParent)
			v.Set("operationId", toCamelCase(parent+" "+body))
		}

		for pair := v.Oldest(); pair != nil; pair = pair.Next() {
			v.Set(pair.Key, processOrdered(pair.Value, parent, pair.Key))
		}
		return v

	case []interface{}:
		//for i, item := range v {
		//	v[i] = processOrdered(item)
		//}
		return v

	default:
		return data
	}
}

func cleanString(s string) string {
	stopWords := map[string]bool{
		// Артикли
		"a": true, "an": true, "the": true,

		// Предлоги и союзы
		"by": true, "of": true, "in": true, "on": true, "at": true,
		"for": true, "or": true, "as": true,
		"with": true, "from": true, "into": true, "via": true, "per": true,

		// Другие служебные слова
		"is": true, "it": true, "its": true, "but": true, "nor": true,
		"not": true, "up": true, "out": true, "so": true, "yet": true,
		"if": true, "off": true, "etc": true, "que": true,
	}

	words := strings.Fields(s)
	var result []string

	for _, word := range words {
		lowerWord := strings.ToLower(word)

		// Сохраняем слово если:
		// 1. Его нет в списке стоп-слов
		// 2. Это параметр вида "by paramName" (сохраняем только paramName)
		if !stopWords[lowerWord] && !strings.HasPrefix(lowerWord, "by ") {
			result = append(result, word)
		} else {
			fmt.Printf("Word: '%s' removed from '%s'\n", word, s)
		}
	}

	return strings.Join(result, " ")
}

func getStringFromOrderedMap(om *orderedmap.OrderedMap[string, interface{}], key string) (string, bool) {
	val, exists := om.Get(key)
	if !exists {
		return "", false
	}

	s, ok := val.(string)
	return s, ok
}

func convertToOrdered(data interface{}) interface{} {
	switch v := data.(type) {
	case map[string]interface{}:
		om := orderedmap.New[string, interface{}]()
		for k, val := range v {
			om.Set(k, convertToOrdered(val))
		}
		return om

	case []interface{}:
		arr := make([]interface{}, len(v))
		for i, val := range v {
			arr[i] = convertToOrdered(val)
		}
		return arr

	default:
		return data
	}
}

func toCamelCase(s string) string {
	reg := regexp.MustCompile(`[\W_]+`)
	words := reg.Split(s, -1)

	if len(words) == 0 {
		return ""
	}

	var b strings.Builder

	for _, word := range words {
		if word != "" {
			b.WriteString(cases.Title(language.English).String(strings.ToLower(word)))
		}
	}

	return b.String()
}

func exitWithError(msg string) {
	fmt.Fprintln(os.Stderr, msg)
	os.Exit(1)
}

func formatPath(path string) string {
	// Удаляем начальные/конечные слэши и разбиваем на сегменты
	trimmed := strings.Trim(path, "/")
	segments := strings.Split(trimmed, "/")

	// Пропускаем первый сегмент
	if len(segments) > 1 {
		segments = segments[1:]
	} else {
		return "" // Если меньше двух сегментов - возвращаем пустую строку
	}

	var result []string
	for _, segment := range segments {
		// Обрабатываем path parameters
		if strings.HasPrefix(segment, "{") && strings.HasSuffix(segment, "}") {
			param := strings.TrimSuffix(strings.TrimPrefix(segment, "{"), "}")
			result = append(result, "by "+toSnakeCase(param))
		} else {
			result = append(result, segment)
		}
	}

	return strings.Join(result, " ")
}

func toSnakeCase(s string) string {
	// Вставляем подчёркивание перед заглавными буквами (кроме первого символа)
	reg := regexp.MustCompile("([a-z0-9])([A-Z])")
	snake := reg.ReplaceAllString(s, "${1}_${2}")

	// Заменяем все неалфавитно-цифровые символы на подчёркивания
	reg = regexp.MustCompile(`[\W\-]+`)
	snake = reg.ReplaceAllString(snake, "_")

	// Приводим к нижнему регистру и убираем лишние подчёркивания
	snake = strings.ToLower(snake)
	snake = strings.Trim(snake, "_")

	// Убираем последовательные подчёркивания
	reg = regexp.MustCompile(`_{2,}`)
	return reg.ReplaceAllString(snake, "_")
}
