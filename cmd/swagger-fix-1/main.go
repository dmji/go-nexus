package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"regexp"
	"strings"

	orderedmap "github.com/wk8/go-ordered-map/v2"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

func main() {
	inputFile := flag.String("input", "../../swagger.json", "Input JSON file")
	outputFile := flag.String("output", "output.json", "Output JSON file")
	flag.Parse()

	inputData, err := os.ReadFile(*inputFile)
	if err != nil {
		exitWithError(fmt.Sprintf("Error reading input file: %v", err))
	}

	var data interface{}
	if err := json.Unmarshal(inputData, &data); err != nil {
		exitWithError(fmt.Sprintf("Error decoding JSON: %v", err))
	}

	processed := processOrdered(convertToOrdered(data), "", "")

	output, err := os.Create(*outputFile)
	if err != nil {
		exitWithError(fmt.Sprintf("Error creating output file: %v", err))
	}
	defer output.Close()

	encoder := json.NewEncoder(output)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(processed); err != nil {
		exitWithError(fmt.Sprintf("Error encoding JSON: %v", err))
	}

	// remake
	inputDataSwagger, err := os.ReadFile(*outputFile)
	if err != nil {
		exitWithError(fmt.Sprintf("Error reading input file: %v", err))
	}

	var dataSwagger AutoGenerated
	if err := json.Unmarshal(inputDataSwagger, &dataSwagger); err != nil {
		exitWithError(fmt.Sprintf("Error decoding JSON: %v", err))
	}

	outputSwagger, err := os.Create("swagger.json")
	if err != nil {
		exitWithError(fmt.Sprintf("Error creating output file: %v", err))
	}
	defer outputSwagger.Close()

	encoderSwagger := json.NewEncoder(outputSwagger)
	encoderSwagger.SetIndent("", "  ")
	if err := encoderSwagger.Encode(dataSwagger); err != nil {
		exitWithError(fmt.Sprintf("Error encoding JSON: %v", err))
	}
}

func processOrdered(data interface{}, grandParent, parent string) interface{} {
	switch v := data.(type) {
	case *orderedmap.OrderedMap[string, interface{}]:
		_, hasSummary := getStringFromOrderedMap(v, "summary")
		_, hasOperationId := v.Get("operationId")

		if hasSummary && hasOperationId {
			v.Set("operationId", toCamelCase(parent+" "+formatPath(grandParent)))
		}

		for pair := v.Oldest(); pair != nil; pair = pair.Next() {
			v.Set(pair.Key, processOrdered(pair.Value, parent, pair.Key))
		}
		return v

	case []interface{}:
		//for i, item := range v {
		//	v[i] = processOrdered(item)
		//}
		return v

	default:
		return data
	}
}

func getStringFromOrderedMap(om *orderedmap.OrderedMap[string, interface{}], key string) (string, bool) {
	val, exists := om.Get(key)
	if !exists {
		return "", false
	}

	s, ok := val.(string)
	return s, ok
}

func convertToOrdered(data interface{}) interface{} {
	switch v := data.(type) {
	case map[string]interface{}:
		om := orderedmap.New[string, interface{}]()
		for k, val := range v {
			om.Set(k, convertToOrdered(val))
		}
		return om

	case []interface{}:
		arr := make([]interface{}, len(v))
		for i, val := range v {
			arr[i] = convertToOrdered(val)
		}
		return arr

	default:
		return data
	}
}

func toCamelCase(s string) string {
	reg := regexp.MustCompile(`[\W_]+`)
	words := reg.Split(s, -1)

	if len(words) == 0 {
		return ""
	}

	var b strings.Builder

	for _, word := range words {
		if word != "" {
			b.WriteString(cases.Title(language.English).String(strings.ToLower(word)))
		}
	}

	return b.String()
}

func exitWithError(msg string) {
	fmt.Fprintln(os.Stderr, msg)
	os.Exit(1)
}

func formatPath(path string) string {
	// Удаляем версию API и начальные/конечные слэши
	trimmed := strings.TrimPrefix(path, "/v1/")
	trimmed = strings.TrimPrefix(trimmed, "/")
	trimmed = strings.TrimSuffix(trimmed, "/")

	parts := strings.Split(trimmed, "/")
	var result []string

	for _, part := range parts {
		// Обрабатываем path parameters
		if strings.HasPrefix(part, "{") && strings.HasSuffix(part, "}") {
			param := strings.TrimSuffix(strings.TrimPrefix(part, "{"), "}")
			result = append(result, "by "+param)
		} else {
			result = append(result, part)
		}
	}

	return strings.Join(result, " ")
}
